generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== Users & Memberships =====
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  avatar    String?
  password  String
  createdAt DateTime @default(now())

  workspaces    WorkspaceMember[]
  boards        BoardMember[]
  cardAssignees CardMember[]
  comments      Comment[]
  activities    Activity[]
  refreshTokens RefreshToken[]
  
  // Notifications
  notifications         Notification[] @relation("notifications")
  triggeredNotifications Notification[] @relation("notificationActors")
  watchedCards          WatchedCard[]
  watchedBoards         WatchedBoard[]
  sentInvitations       PendingInvitation[]
}

model Workspace {
  id          String            @id @default(cuid())
  name        String            @unique
  description String?
  
  // Visibility & Permission Settings
  visibility  WorkspaceVisibility @default(private)
  isPersonal  Boolean             @default(false)
  
  // Permission Settings
  whoCanCreateBoards  PermissionLevel @default(members)
  whoCanInviteMembers PermissionLevel @default(members)
  
  // Email domain restrictions (comma-separated, e.g., "company.com,partner.com")
  allowedEmailDomains String?
  
  // Default settings for new boards
  defaultBoardVisibility Visibility @default(workspace)
  
  members     WorkspaceMember[]
  pendingInvitations PendingInvitation[]
  boards      Board[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
}

model WorkspaceMember {
  id          String    @id @default(cuid())
  role        Role
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String

  @@unique([userId, workspaceId])
}

model PendingInvitation {
  id          String    @id @default(cuid())
  email       String
  role        Role      @default(member)
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String
  inviter     User      @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  inviterId   String
  createdAt   DateTime  @default(now())

  board       Board?    @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId     String?

  // Allow multiple invites per workspace if they are for different boards
  // Note: In Postgres, multiple rows with NULL boardId are considered distinct for unique constraints unless using NULLS NOT DISTINCT (PG 15+).
  // For safety and simplicity in this MVP, we'll remove the strict unique constraint on workspace+email
  // and rely on application logic or just allow multiple.
  // But to prevent spam, let's keep an index.
  @@index([email])
  @@index([workspaceId, email])
}

enum WorkspaceVisibility {
  private   // Only members can see
  public    // Anyone can view (but not edit)
}

enum PermissionLevel {
  admins    // Only admins/owners can perform action
  members   // All members can perform action
}

enum Visibility {
  private
  workspace
  public
}

model Board {
  id          String        @id @default(cuid())
  name        String
  description String?
  isArchived  Boolean       @default(false)
  background  String?
  visibility  Visibility    @default(private)

  workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String
  lists       List[]
  labels      Label[]
  members     BoardMember[]
  activities  Activity[]
  notifications Notification[]
  watchedBy   WatchedBoard[]
  pendingInvitations PendingInvitation[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@unique([workspaceId, name])
}

model BoardMember {
  id      String @id @default(cuid())
  role    Role
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  board   Board  @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId String

  @@unique([userId, boardId])
}

// ===== Lists / Cards / Labels =====
model List {
  id   String @id @default(cuid())
  name String

  // Deprecated: kept temporarily for compatibility, will be removed later
  position Int?

  // New: string rank for O(1) reorder
  rank String @default("n")
  isArchived Boolean @default(false)

  board    Board  @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId  String
  wipLimit Int?
  cards    Card[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([boardId, rank])
}

enum Risk {
  low
  medium
  high
}

model Card {
  id          String  @id @default(cuid())
  title       String
  description String?

  // Deprecated: kept temporarily
  position Int?

  // New rank
  rank String @default("n")

  list        List         @relation(fields: [listId], references: [id], onDelete: Cascade)
  listId      String
  startDate   DateTime?
  dueDate     DateTime?
  estimate    Float?
  risk        Risk?
  priority    Priority     @default(medium)
  isArchived  Boolean      @default(false)
  labels      CardLabel[]
  assignees   CardMember[]
  checklists  Checklist[]
  attachments Attachment[]
  comments    Comment[]
  activities  Activity[]
  notifications Notification[]
  watchedBy   WatchedCard[]
  isDone      Boolean      @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([listId, rank])
}

model Label {
  id         String  @id @default(cuid())
  name       String
  color      String
  // ordering & archive
  rank       String  @default("n")
  isArchived Boolean @default(false)

  board   Board       @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId String
  cards   CardLabel[]

  // allow same name if color differs; give the DB constraint a stable name
  @@unique([boardId, name, color], map: "label_board_name_color_unique")
  @@index([boardId, rank], map: "label_board_rank_idx")
}

model CardLabel {
  cardId    String
  labelId   String
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  label     Label    @relation(fields: [labelId], references: [id], onDelete: Cascade)
  // NEW: audit
  createdAt DateTime @default(now())

  @@id([cardId, labelId])
}

model CardMember {
  cardId     String
  userId     String
  card       Card   @relation(fields: [cardId], references: [id], onDelete: Cascade)
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role       CardRole?
  customRole String?  @db.VarChar(64)

  @@id([cardId, userId])
  @@index([userId])
}

// ===== Checklists / Attachments / Comments / Activity =====
model Checklist {
  id       String          @id @default(cuid())
  title    String
  position Int
  card     Card            @relation(fields: [cardId], references: [id], onDelete: Cascade)
  cardId   String
  items    ChecklistItem[]
}

model ChecklistItem {
  id          String    @id @default(cuid())
  text        String
  done        Boolean   @default(false)
  position    Int
  checklist   Checklist @relation(fields: [checklistId], references: [id], onDelete: Cascade)
  checklistId String
}

model Attachment {
  id             String          @id @default(cuid())
  name           String? // will become required
  url            String
  mime           String? // will become required
  bytes          Int? // legacy
  size           Int? // NEW (temporary nullable)
  isCover        Boolean         @default(false)
  createdBy      String?
  card           Card            @relation(fields: [cardId], references: [id], onDelete: Cascade)
  cardId         String
  createdAt      DateTime        @default(now())
  downloadTokens DownloadToken[]

  @@index([cardId, createdAt])
}

model DownloadToken {
  id           String    @id @default(cuid()) // internal id (not exposed)
  jti          String    @unique // token id from JWT
  attachmentId String
  createdAt    DateTime  @default(now())
  usedAt       DateTime?
  expiresAt    DateTime

  attachment Attachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@index([attachmentId])
  @@index([expiresAt])
}

model Comment {
  id        String   @id @default(cuid())
  text      String
  createdAt DateTime @default(now())
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  cardId    String
}

model Activity {
  id        String   @id @default(cuid())
  type      String
  payload   Json
  createdAt DateTime @default(now())
  board     Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId   String
  // Optional relations for better querying
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId    String?
  card      Card?    @relation(fields: [cardId], references: [id], onDelete: SetNull)
  cardId    String?
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

// ===== Enums =====
enum Role {
  owner
  admin
  member
  viewer
}

enum Priority {
  low
  medium
  high
  urgent
}

// NEW: functional role on card assignments (not permissions)
enum CardRole {
  developer
  designer
  qa
  analyst
  pm
  devops
  other
}

// ===== Notifications =====

enum NotificationType {
  MENTIONED           // @mentioned in comment
  ASSIGNED_TO_CARD    // added as card assignee
  CARD_COMMENT        // comment on watched/assigned card
  CARD_DUE_SOON       // due date reminder
  CARD_MOVED          // card moved (if watching)
  ADDED_TO_BOARD      // invited to board
  ADDED_TO_WORKSPACE  // invited to workspace
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String           // e.g., "John mentioned you in a comment"
  message   String?          // Optional detailed message
  isRead    Boolean          @default(false)
  
  // Who receives this notification
  user      User             @relation("notifications", fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  
  // Who triggered this notification (can be null for system notifications)
  actor     User?            @relation("notificationActors", fields: [actorId], references: [id], onDelete: SetNull)
  actorId   String?
  
  // Context - what the notification is about
  card      Card?            @relation(fields: [cardId], references: [id], onDelete: Cascade)
  cardId    String?
  
  board     Board?           @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId   String?
  
  // Additional context as JSON
  metadata  Json?            // { commentId, listName, etc. }
  
  createdAt DateTime         @default(now())
  
  @@index([userId, isRead])
  @@index([userId, createdAt])
}

model WatchedCard {
  id      String @id @default(cuid())
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  card    Card   @relation(fields: [cardId], references: [id], onDelete: Cascade)
  cardId  String
  
  @@unique([userId, cardId])
}

model WatchedBoard {
  id      String @id @default(cuid())
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  board   Board  @relation(fields: [boardId], references: [id], onDelete: Cascade)
  boardId String
  
  @@unique([userId, boardId])
}
